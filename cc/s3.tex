\documentclass{article}

\usepackage{amsmath}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\lstset
{language=Haskell
,basicstyle=\footnotesize
,extendedchars=true
,frame=single
}

\begin{document}
\title{Compiler Construction -- supervision 3}
\author{James Wood}
\maketitle

\begin{enumerate}
  \item
    \begin{enumerate}
      \item The program counter is a number referring to the address in memory of the next instruction to execute.
      \item Calling conventions specify how a compiler will implement procedure calls. These have to be known when compiling a call, as well as when compiling the returning procedure of a subroutine. One calling convention may be to produce code like this:
        \begin{lstlisting}[language={[x86masm]Assembler},showstringspaces=false]
callee:
    # do stuff, assuming that the argument is in 0($sp)
    load $ra 8($sp)  # get the saved return address
    addi $ra $ra 4  # go 1 instruction down to avoid jumping again
    subi $sp $sp 12  # move stack pointer back
    jr $ra

caller:
    # ...
    addi $sp $sp 12  # start a new stack frame
    store $locals 0($sp)  # stack frame has a pointer to the caller's
    store $arg 4($sp)     # local variables, one argument, and a return
    store $pc 8($sp)      # address.
    jump callee
    load $locals 0($sp)
    # ...\end{lstlisting}
      \item The source language usually allows us to call functions from within other functions to an arbitrary depth, and we usually represent function calls in the source language by a call to an implicit subroutine in machine code. This self-similarity, combined with the fact that we generally only care about the most recent calls at a given time, mean that stacks lend themselves well to the problem. The call stack could be avoided by converting to continuation passing style, and always storing the state of the program on the heap in continuations.
      \item Calling conventions are emergent properties of the machine code generated by a compiler. Evaluation strategies are semantic specifications made in terms of source programs (or at least their ASTs).
      \item This implementation makes a new C function call with each source language function call, and keeps all of the calls on the stack. This is likely to eventually fill the stack, even without excessive recursion.
      \item \texttt{while} loops do not use stack frames, so the previous problem has been alleviated. The C call stack only grows to contain a few frames, and is not based on the calls made in the source program.
      \item The address of the current continuation can be stored in a register, and is updated by a driver loop, much as in the C program.
    \end{enumerate}
  \item
    \begin{enumerate}
      \item A closure needs to keep reference to the compiled code associated with it and the variables which have been bound from outside. We assume that the order of variables is known and set.
        \begin{lstlisting}[language=C]
struct Closure {
  void *code;
  size_t length;
  Closure (*vars)[];
}
        \end{lstlisting}
      \item First, we check whether the next $k$ spaces in the heap are free. If they are, we mark them taken and advance the pointer to the next free location by $k$. Otherwise, we start looking for suitable heap space from where we found the taken heap word. If we get back to the free word pointer in this checking procedure, we have insufficient heap space, and throw a run-time error.
      \item We may store an integer with \texttt{HEAP\_SIZE} bits, each bit signifying whether the corresponding heap address is taken. This has to be updated with each allocation and de\"allocation. An alternative is to designate the top bit of each word to do a similar job.
      \item
        \begin{lstlisting}[language=C]
struct Closure fyc;
fyc.code = fy_entry;
fyc.length = 2;
fyc.vars = {f,y};
        \end{lstlisting}
      \item The free variables are already in the closure, stored in a fixed order. The code has been compiled so that it refers to indexes in the closure's list of variables, rather than names. If there are few enough free variables, they can be loaded into registers for the duration of the call. The code of the closure has access to the stack pointer, so can find arguments as it would without the closure mechanism.
    \end{enumerate}
\end{enumerate}

\section*{Practical exercises}
See the commit history of \url{https://github.com/laMudri/compconstr-code} on the branch \texttt{exercise3}.

\end{document}
